# Place all the behaviors and hooks related to the matching controller here.
# All this logic will automatically be available in application.js.
# You can use CoffeeScript in this file: http://coffeescript.org/

state =
bag_size: 3,
pool: "abcdefg",
stashes: {
        'leon': [[3, 'lfoel'], [1, 'guacamolee'], [2, 'heloe']],
        'aaa': [[3, 'lkhoel'], [1, 'guacamoleeeee'], [2, 'heloe']]
    }

TILE_IMAGES = {
<% ('a'..'z').each do |c| %>
  <%= c %>: '<%= asset_path "tiles/#{c}.png" %>'
<% end %>
}

window.initTable = () ->
    gameState = {}
    window.next_turn_number = 15

    initSocket = () ->
        #dispatcher = new WebSocketRails("serene-dawn-1769.herokuapp.com/websocket")
        dispatcher = new WebSocketRails(window.document.location.host + "/websocket")

        # TODO remove
        window.dispatcher = dispatcher

        dispatcher.on_open = (data) ->
            dispatcher.trigger 'table.state_request'

        $('#flip_tile').on 'click', () ->
            console.log "tile flip requested!" + window.next_turn_number
            dispatcher.trigger 'table.flip_tile_request', window.next_turn_number

        $('#word_entry').on 'keypress', (event, abc) ->
            if(event.which == 13)
                # TODO fix redundant $('#word_entry')
                dispatcher.trigger 'table.build_request', $('#word_entry').val()
                $('#word_entry').val('')

        dispatcher.bind 'game_info.next_turn_number', (response) ->
            alert('Receiving next turn number')
            window.next_turn_number = response

        dispatcher.bind 'game_event.new_state', (response) ->
            alert('new move!')
            $('#gamelog').append($('<div/>').html(response))
            updateAll(response)
            #console.log(response)
            #$('#gamelog').append($('<div/>').html(response.message))

    updateAll = (state) ->
        console.log state.next_turn_number
        window.next_turn_number = state.next_turn_number
        updateBag(state)
        updatePool(state)
        updateStashes(state)
        updateScore(state)
        if (state.bag_size == 0) 
            $('#flip_tile').text("End Game")

    updateBag = (state) ->
        console.log("updating bag")
        $bagBox = $('#bagBox')
        $bagBox.html(state.bag_size)

    updateScore = (state) ->
        console.log('updating score')
        $score = $('#score')
        $score.html("Score: " + state.score)

    appendLetter = ($elt, letter) ->
        $tile = $('<img src="' + TILE_IMAGES[letter] + '" hspace="1">').addClass('tile')
        $elt.append($tile)

    updatePool = (state) ->
        console.log("updating pool")
        $poolDiv = $('#poolDiv')
        $poolDiv.html('')
        letters = state.pool
        i = 0
        letters.split("").forEach((letter) ->
            if (i%10==0)
                $poolDiv.append("<br>")
            i++
            appendLetter($poolDiv, letter)
        )

    updateSingleStash = (state, stashName) ->
        $stashDiv = findStashDivByName(stashName)
        $stashDiv.html('')

        state.stashes[stashName].forEach((entry) ->
            $wordDiv = $("<div>").attr('turnNumber', entry[0]).addClass('wordDiv')
            entry[1].split('').forEach((letter) ->
                appendLetter($wordDiv, letter)
            )
            $wordDiv.on 'click', () ->
                submitMorph(entry[0])
                $('#word_entry').val('') 

            f1 = () -> $wordDiv.addClass("hasBorder")
            f2 = () -> $wordDiv.removeClass("hasBorder")
            $wordDiv.hover( f1, f2 )
            $stashDiv.append($wordDiv)
            $stashDiv.append("<br>")
            console.log entry
        )

    submitMorph = (changed_turn_number) ->
        # TODO don't use window.dispatcher
        window.dispatcher.trigger 'table.morph_request', {
          changed_turn_number: changed_turn_number,
          word: $('#word_entry').val()
        }

    updateStashes = (state) ->
        console.log("updating stashesE")
        # alert('Updating stashes,' + state.stashes['ben'])
        updateSingleStash(state, name) for name, words of state.stashes

    findStashDivByName = (name) ->
        # TODO for multiplayer mode, this will need to be a nontrivial method
        return $("#stashDiv")

    window.show_table_setup = () ->
    # onready = () ->
        initSocket()
        state.stashes[fiend].sort((pair1, pair2) ->
          return pair1[0] - pair2[0]
        ) for fiend in state.stashes

    # $ -> onready()
